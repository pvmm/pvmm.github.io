/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/* This file was autogenerated from ../../../pvmm.github.io/C.tmLanguage (uuid: ) */
/****************************************************************************************
 * IT MIGHT NOT BE PERFECT ...But it's a good start from an existing *.tmlanguage file. *
 * fileTypes                                                                            *
 ****************************************************************************************/

"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var CHighlightRules = function() {
    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    this.$rules = {
        start: [{
            include: "#preprocessor-rule-enabled"
        }, {
            include: "#preprocessor-rule-disabled"
        }, {
            include: "#preprocessor-rule-other"
        }, {
            include: "#comments"
        }, {
            token: "keyword.control.c",
            regex: /\b(?:break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|while)\b/
        }, {
            token: "storage.type.c",
            regex: /\b(?:asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\b/
        }, {
            token: "storage.modifier.c",
            regex: /\b(?:const|extern|register|restrict|static|volatile|inline)\b/
        }, {
            token: "constant.other.variable.mac-classic.c",
            regex: /\bk[A-Z]\w*\b/,
            comment: "common C constant naming idiom -- kConstantVariable"
        }, {
            token: "variable.other.readwrite.global.mac-classic.c",
            regex: /\bg[A-Z]\w*\b/
        }, {
            token: "variable.other.readwrite.static.mac-classic.c",
            regex: /\bs[A-Z]\w*\b/
        }, {
            token: "constant.language.c",
            regex: /\b(?:NULL|true|false|TRUE|FALSE)\b/
        }, {
            include: "#sizeof"
        }, {
            token: "constant.numeric.c",
            regex: /\b(?:0(?:x|X)[0-9a-fA-F]*|(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:(?:e|E)(?:\+|-)?[0-9]+)?)(?:L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\b/
        }, {
            token: "punctuation.definition.string.begin.c",
            regex: /"/,
            push: [{
                token: "punctuation.definition.string.end.c",
                regex: /"/,
                next: "pop"
            }, {
                include: "#string_escaped_char"
            }, {
                include: "#string_placeholder"
            }, {
                defaultToken: "string.quoted.double.c"
            }]
        }, {
            token: "punctuation.definition.string.begin.c",
            regex: /'/,
            push: [{
                token: "punctuation.definition.string.end.c",
                regex: /'/,
                next: "pop"
            }, {
                include: "#string_escaped_char"
            }, {
                defaultToken: "string.quoted.single.c"
            }]
        }, {
            token: [
                "meta.preprocessor.macro.c",
                "keyword.control.import.define.c",
                "meta.preprocessor.macro.c",
                "entity.name.function.preprocessor.c",
                "meta.preprocessor.macro.c",
                "punctuation.definition.parameters.c",
                "variable.parameter.preprocessor.c",
                "punctuation.separator.parameters.c"
            ],
            regex: /^(\s*\#\s*)(define)(\s+)((?<d>[a-zA-Z_][a-zA-Z0-9_]*))(?:(\()(\s*\g<id>\s*)((?:,\s*\g<id>\s*)*)(?:\.\.\.)?(\)))?/,
            caseInsensitive: true,
            push: [{
                token: "meta.preprocessor.macro.c",
                regex: /(?=(?:\/\/|\/\*))|$/,
                next: "pop"
            }, {
                token: "punctuation.separator.continuation.c",
                regex: "(?>\\\\\\s*$)",
                TODO: "FIXME: regexp doesn't have js equivalent",
                originalRegex: "(?>\\\\\\s*\\n)"
            }, {
                include: "$base"
            }, {
                defaultToken: "meta.preprocessor.macro.c"
            }]
        }, {
            token: [
                "meta.preprocessor.diagnostic.c",
                "keyword.control.import.error.c"
            ],
            regex: /^(\s*#\s*)(error|warning)\b/,
            push: [{
                token: [],
                regex: /$/,
                next: "pop"
            }, {
                token: "punctuation.separator.continuation.c",
                regex: "(?>\\\\\\s*$)",
                TODO: "FIXME: regexp doesn't have js equivalent",
                originalRegex: "(?>\\\\\\s*\\n)"
            }, {
                defaultToken: "meta.preprocessor.diagnostic.c"
            }]
        }, {
            token: [
                "meta.preprocessor.c.include",
                "keyword.control.import.include.c",
                "meta.preprocessor.c.include"
            ],
            regex: /^(\s*#\s*)(include|import)\b(\s+)/,
            push: [{
                token: [],
                regex: /(?=(?:\/\/|\/\*))|$/,
                next: "pop"
            }, {
                token: "punctuation.separator.continuation.c",
                regex: "(?>\\\\\\s*$)",
                TODO: "FIXME: regexp doesn't have js equivalent",
                originalRegex: "(?>\\\\\\s*\\n)"
            }, {
                token: "punctuation.definition.string.begin.c",
                regex: /"/,
                push: [{
                    token: "punctuation.definition.string.end.c",
                    regex: /"/,
                    next: "pop"
                }, {
                    defaultToken: "string.quoted.double.include.c"
                }]
            }, {
                token: "punctuation.definition.string.begin.c",
                regex: /</,
                push: [{
                    token: "punctuation.definition.string.end.c",
                    regex: />/,
                    next: "pop"
                }, {
                    defaultToken: "string.quoted.other.lt-gt.include.c"
                }]
            }, {
                defaultToken: "meta.preprocessor.c.include"
            }]
        }, {
            include: "#pragma-mark"
        }, {
            token: [
                "meta.preprocessor.c",
                "keyword.control.import.c"
            ],
            regex: /^(\s*#\s*)(define|defined|elif|else|if|ifdef|ifndef|line|pragma|undef)\b/,
            push: [{
                token: [],
                regex: /(?=(?:\/\/|\/\*))|$/,
                next: "pop"
            }, {
                token: "punctuation.separator.continuation.c",
                regex: "(?>\\\\\\s*$)",
                TODO: "FIXME: regexp doesn't have js equivalent",
                originalRegex: "(?>\\\\\\s*\\n)"
            }, {
                defaultToken: "meta.preprocessor.c"
            }]
        }, {
            token: "support.type.sys-types.c",
            regex: /\b(?:u_char|u_short|u_int|u_long|ushort|uint|u_quad_t|quad_t|qaddr_t|caddr_t|daddr_t|dev_t|fixpt_t|blkcnt_t|blksize_t|gid_t|in_addr_t|in_port_t|ino_t|key_t|mode_t|nlink_t|id_t|pid_t|off_t|segsz_t|swblk_t|uid_t|id_t|clock_t|size_t|ssize_t|time_t|useconds_t|suseconds_t)\b/
        }, {
            token: "support.type.pthread.c",
            regex: /\b(?:pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\b/
        }, {
            token: "support.type.stdint.c",
            regex: /\b(?:int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|int_least8_t|int_least16_t|int_least32_t|int_least64_t|uint_least8_t|uint_least16_t|uint_least32_t|uint_least64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|uint_fast8_t|uint_fast16_t|uint_fast32_t|uint_fast64_t|intptr_t|uintptr_t|intmax_t|intmax_t|uintmax_t|uintmax_t)\b/
        }, {
            token: "support.constant.mac-classic.c",
            regex: /\b(?:noErr|kNilOptions|kInvalidID|kVariableLengthArray)\b/
        }, {
            token: "support.type.mac-classic.c",
            regex: /\b(?:AbsoluteTime|Boolean|Byte|ByteCount|ByteOffset|BytePtr|CompTimeValue|ConstLogicalAddress|ConstStrFileNameParam|ConstStringPtr|Duration|Fixed|FixedPtr|Float32|Float32Point|Float64|Float80|Float96|FourCharCode|Fract|FractPtr|Handle|ItemCount|LogicalAddress|OptionBits|OSErr|OSStatus|OSType|OSTypePtr|PhysicalAddress|ProcessSerialNumber|ProcessSerialNumberPtr|ProcHandle|Ptr|ResType|ResTypePtr|ShortFixed|ShortFixedPtr|SignedByte|SInt16|SInt32|SInt64|SInt8|Size|StrFileName|StringHandle|StringPtr|TimeBase|TimeRecord|TimeScale|TimeValue|TimeValue64|UInt16|UInt32|UInt64|UInt8|UniChar|UniCharCount|UniCharCountPtr|UniCharPtr|UnicodeScalarValue|UniversalProcHandle|UniversalProcPtr|UnsignedFixed|UnsignedFixedPtr|UnsignedWide|UTF16Char|UTF32Char|UTF8Char)\b/
        }, {
            include: "#block"
        }, {
            token: [
                "punctuation.whitespace.function.leading.c",
                "entity.name.function.c",
                "meta.function.c"
            ],
            regex: /(?:^|(?:(?=\s)(?<!else|new|return)(?<=\w)|(?=\s*[A-Za-z_])(?<!&&)(?<=[*&>])))(\s*)(?!(?:while|for|do|if|else|switch|catch|enumerate|return|r?iterate)\s*\()((?:[A-Za-z_][A-Za-z0-9_]*|::)+|(?<=operator)(?:[-*&<>=+!]+|\(\)|\[\]))(\s*)(?=\()/,
            push: [{
                token: "meta.function.c",
                regex: /(?<=\})|(?=#)|;/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                include: "#parens"
            }, {
                token: "storage.modifier.c",
                regex: /\bconst\b/
            }, {
                include: "#block"
            }, {
                defaultToken: "meta.function.c"
            }]
        }],
        "#access": [{
            token: "variable.other.dot-access.c",
            regex: /\.[a-zA-Z_][a-zA-Z_0-9]*\b(?!\s*\()/
        }],
        "#block": [{
            token: "meta.block.c",
            regex: /\{/,
            push: [{
                token: "meta.block.c",
                regex: /\}/,
                next: "pop"
            }, {
                include: "#block_innards"
            }, {
                defaultToken: "meta.block.c"
            }]
        }],
        "#block_innards": [{
            include: "#preprocessor-rule-enabled-block"
        }, {
            include: "#preprocessor-rule-disabled-block"
        }, {
            include: "#preprocessor-rule-other-block"
        }, {
            include: "#sizeof"
        }, {
            include: "#access"
        }, {
            token: [
                "punctuation.whitespace.support.function.leading.c",
                "support.function.C99.c"
            ],
            regex: /(\s*)\b(hypot(?:f|l)?|s(?:scanf|ystem|nprintf|ca(?:nf|lb(?:n(?:f|l)?|ln(?:f|l)?))|i(?:n(?:h(?:f|l)?|f|l)?|gn(?:al|bit))|tr(?:s(?:tr|pn)|nc(?:py|at|mp)|c(?:spn|hr|oll|py|at|mp)|to(?:imax|d|u(?:l(?:l)?|max)|k|f|l(?:d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(?:jmp|vbuf|locale|buf)|qrt(?:f|l)?|w(?:scanf|printf)|rand)|n(?:e(?:arbyint(?:f|l)?|xt(?:toward(?:f|l)?|after(?:f|l)?))|an(?:f|l)?)|c(?:s(?:in(?:h(?:f|l)?|f|l)?|qrt(?:f|l)?)|cos(?:h(?:f)?|f|l)?|imag(?:f|l)?|t(?:ime|an(?:h(?:f|l)?|f|l)?)|o(?:s(?:h(?:f|l)?|f|l)?|nj(?:f|l)?|pysign(?:f|l)?)|p(?:ow(?:f|l)?|roj(?:f|l)?)|e(?:il(?:f|l)?|xp(?:f|l)?)|l(?:o(?:ck|g(?:f|l)?)|earerr)|a(?:sin(?:h(?:f|l)?|f|l)?|cos(?:h(?:f|l)?|f|l)?|tan(?:h(?:f|l)?|f|l)?|lloc|rg(?:f|l)?|bs(?:f|l)?)|real(?:f|l)?|brt(?:f|l)?)|t(?:ime|o(?:upper|lower)|an(?:h(?:f|l)?|f|l)?|runc(?:f|l)?|gamma(?:f|l)?|mp(?:nam|file))|i(?:s(?:space|n(?:ormal|an)|cntrl|inf|digit|u(?:nordered|pper)|p(?:unct|rint)|finite|w(?:space|c(?:ntrl|type)|digit|upper|p(?:unct|rint)|lower|al(?:num|pha)|graph|xdigit|blank)|l(?:ower|ess(?:equal|greater)?)|al(?:num|pha)|gr(?:eater(?:equal)?|aph)|xdigit|blank)|logb(?:f|l)?|max(?:div|abs))|di(?:v|fftime)|_Exit|unget(?:c|wc)|p(?:ow(?:f|l)?|ut(?:s|c(?:har)?|wc(?:har)?)|error|rintf)|e(?:rf(?:c(?:f|l)?|f|l)?|x(?:it|p(?:2(?:f|l)?|f|l|m1(?:f|l)?)?))|v(?:s(?:scanf|nprintf|canf|printf|w(?:scanf|printf))|printf|f(?:scanf|printf|w(?:scanf|printf))|w(?:scanf|printf)|a_(?:start|copy|end|arg))|qsort|f(?:s(?:canf|e(?:tpos|ek))|close|tell|open|dim(?:f|l)?|p(?:classify|ut(?:s|c|w(?:s|c))|rintf)|e(?:holdexcept|set(?:e(?:nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(?:aiseexcept|ror)|get(?:e(?:nv|xceptflag)|round))|flush|w(?:scanf|ide|printf|rite)|loor(?:f|l)?|abs(?:f|l)?|get(?:s|c|pos|w(?:s|c))|re(?:open|e|ad|xp(?:f|l)?)|m(?:in(?:f|l)?|od(?:f|l)?|a(?:f|l|x(?:f|l)?)?))|l(?:d(?:iv|exp(?:f|l)?)|o(?:ngjmp|cal(?:time|econv)|g(?:1(?:p(?:f|l)?|0(?:f|l)?)|2(?:f|l)?|f|l|b(?:f|l)?)?)|abs|l(?:div|abs|r(?:int(?:f|l)?|ound(?:f|l)?))|r(?:int(?:f|l)?|ound(?:f|l)?)|gamma(?:f|l)?)|w(?:scanf|c(?:s(?:s(?:tr|pn)|nc(?:py|at|mp)|c(?:spn|hr|oll|py|at|mp)|to(?:imax|d|u(?:l(?:l)?|max)|k|f|l(?:d|l)?|mbs)|pbrk|ftime|len|r(?:chr|tombs)|xfrm)|to(?:b|mb)|rtomb)|printf|mem(?:set|c(?:hr|py|mp)|move))|a(?:s(?:sert|ctime|in(?:h(?:f|l)?|f|l)?)|cos(?:h(?:f|l)?|f|l)?|t(?:o(?:i|f|l(?:l)?)|exit|an(?:h(?:f|l)?|2(?:f|l)?|f|l)?)|b(?:s|ort))|g(?:et(?:s|c(?:har)?|env|wc(?:har)?)|mtime)|r(?:int(?:f|l)?|ound(?:f|l)?|(?:e)(?:(?:name)|(?:alloc)|(?:wind)|(?:m)(?:(?:ove)|(?:quo)(?:f|l)?|(?:ainder)(?:f|l)?))|(?:a)(?:nd|ise))|(?:b)(?:search|towc)|(?:m)(?:(?:odf)(?:f|l)?|(?:em)(?:(?:set)|(?:c)(?:hr|py|mp)|(?:move))|(?:ktime)|(?:alloc)|(?:b)(?:(?:s)(?:init|towcs|rtowcs)|(?:towc)|(?:len)|(?:r)(?:towc|len))))\b/
        }, {
            token: [
                "punctuation.whitespace.function-call.leading.c",
                "punctuation.definition.parameters.c",
                "support.function.any-method.c",
                "meta.function-call.c",
                "meta.function-call.c"
            ],
            regex: /(?:(?=\s)(?:(?<=else|new|return)|(?<!\w))(\s+))?\b(while|for|do|if|else|switch|catch|enumerate|return|r?iterate)(\s*\()(?:(?!NS)[A-Za-z_][A-Za-z0-9_]*\b|::)+(\s*)(\()/
        }, {
            token: [
                "variable.other.c",
                "meta.initialization.c",
                "punctuation.definition.parameters.c"
            ],
            regex: /(?=\s)(?<!else|new|return)(?<=\w)\s+((?:[A-Za-z_][A-Za-z0-9_]*|::)+|(?:(?<=operator)(?:[-*&<>=+!]+|\(\)|\[\]))?)(\s*)(\()/
        }, {
            include: "#block"
        }, {
            include: "$base"
        }],
        "#comments": [{
            token: [
                "comment.block.c",
                "meta.toc-list.banner.block.c",
                "comment.block.c"
            ],
            regex: /^(\/\* =)(\s*.*?)(\s*= \*\/$)/
        }, {
            token: "punctuation.definition.comment.c",
            regex: /\/\*/,
            push: [{
                token: "punctuation.definition.comment.c",
                regex: /\*\//,
                next: "pop"
            }, {
                defaultToken: "comment.block.c"
            }]
        }, {
            token: "invalid.illegal.stray-comment-end.c",
            regex: /\*\/.*$/
        }, {
            token: [
                "comment.line.banner.c++",
                "meta.toc-list.banner.line.c",
                "comment.line.banner.c++"
            ],
            regex: /^(\/\/ =)(\s*.*?)(\s*=\s*$)/
        }, {
            token: "punctuation.definition.comment.c",
            regex: /\/\//,
            push: [{
                token: "comment.line.double-slash.c++",
                regex: /$/,
                next: "pop"
            }, {
                token: "punctuation.separator.continuation.c++",
                regex: "(?>\\\\\\s*$)",
                TODO: "FIXME: regexp doesn't have js equivalent",
                originalRegex: "(?>\\\\\\s*\\n)"
            }, {
                defaultToken: "comment.line.double-slash.c++"
            }]
        }],
        "#disabled": [{
            token: "text",
            regex: /^\s*#\s*if(?:n?def)?\b.*$/,
            push: [{
                token: "text",
                regex: /^\s*#\s*endif\b.*$/,
                next: "pop"
            }, {
                include: "#disabled"
            }, {
                include: "#pragma-mark"
            }],
            comment: "eat nested preprocessor if(def)s"
        }],
        "#parens": [{
            token: "meta.parens.c",
            regex: /\(/,
            push: [{
                token: "meta.parens.c",
                regex: /\)/,
                next: "pop"
            }, {
                include: "$base"
            }, {
                defaultToken: "meta.parens.c"
            }]
        }],
        "#pragma-mark": [{
            token: [
                "meta.section",
                "meta.preprocessor.c",
                "keyword.control.import.pragma.c",
                "meta.preprocessor.c",
                "meta.toc-list.pragma-mark.c"
            ],
            regex: /^(\s*)(#\s*)(pragma\s+mark)(\s+)(.*)/
        }],
        "#preprocessor-rule-disabled": [{
            token: [
                "text",
                "meta.preprocessor.c",
                "keyword.control.import.if.c",
                "meta.preprocessor.c",
                "constant.numeric.preprocessor.c",
                "text"
            ],
            regex: /^(\s*)(#)(if)(\s+)(0)\b(.*)/,
            push: [{
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.if.c"
                ],
                regex: /^(\s*)(#\s*)(endif)\b/,
                next: "pop"
            }, {
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.else.c"
                ],
                regex: /^(\s*)(#\s*)(else)\b/,
                push: [{
                    token: [],
                    regex: /(?=^\s*#\s*endif\b.*$)/,
                    next: "pop"
                }, {
                    include: "$base"
                }]
            }, {
                token: "comment.block.preprocessor.if-branch",
                regex: /(?:)/,
                push: [{
                    token: "comment.block.preprocessor.if-branch",
                    regex: /(?=^\s*#\s*(?:else|endif)\b.*$)/,
                    next: "pop"
                }, {
                    include: "#disabled"
                }, {
                    include: "#pragma-mark"
                }, {
                    defaultToken: "comment.block.preprocessor.if-branch"
                }]
            }]
        }],
        "#preprocessor-rule-disabled-block": [{
            token: [
                "text",
                "meta.preprocessor.c",
                "keyword.control.import.if.c",
                "meta.preprocessor.c",
                "constant.numeric.preprocessor.c",
                "text"
            ],
            regex: /^(\s*)(#)(if)(\s+)(0)\b(.*)/,
            push: [{
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.if.c"
                ],
                regex: /^(\s*)(#\s*)(endif)\b/,
                next: "pop"
            }, {
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.else.c"
                ],
                regex: /^(\s*)(#\s*)(else)\b/,
                push: [{
                    token: [],
                    regex: /(?=^\s*#\s*endif\b.*$)/,
                    next: "pop"
                }, {
                    include: "#block_innards"
                }]
            }, {
                token: "comment.block.preprocessor.if-branch.in-block",
                regex: /(?:)/,
                push: [{
                    token: "comment.block.preprocessor.if-branch.in-block",
                    regex: /(?=^\s*#\s*(?:else|endif)\b.*$)/,
                    next: "pop"
                }, {
                    include: "#disabled"
                }, {
                    include: "#pragma-mark"
                }, {
                    defaultToken: "comment.block.preprocessor.if-branch.in-block"
                }]
            }]
        }],
        "#preprocessor-rule-enabled": [{
            token: [
                "text",
                "meta.preprocessor.c",
                "keyword.control.import.if.c",
                "meta.preprocessor.c",
                "constant.numeric.preprocessor.c"
            ],
            regex: /^(\s*)(#)(if)(\s+)(0*1)\b/,
            push: [{
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.if.c"
                ],
                regex: /^(\s*)(#\s*)(endif)\b/,
                next: "pop"
            }, {
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.else.c",
                    "text"
                ],
                regex: /^(\s*)(#\s*)(else)\b(.*)/,
                push: [{
                    token: [],
                    regex: /(?=^\s*#\s*endif\b.*$)/,
                    next: "pop"
                }, {
                    include: "#disabled"
                }, {
                    include: "#pragma-mark"
                }, {
                    defaultToken: "comment.block.preprocessor.else-branch"
                }]
            }, {
                token: "text",
                regex: /(?:)/,
                push: [{
                    token: "text",
                    regex: /(?=^\s*#\s*(?:else|endif)\b.*$)/,
                    next: "pop"
                }, {
                    include: "$base"
                }]
            }]
        }],
        "#preprocessor-rule-enabled-block": [{
            token: [
                "text",
                "meta.preprocessor.c",
                "keyword.control.import.if.c",
                "meta.preprocessor.c",
                "constant.numeric.preprocessor.c"
            ],
            regex: /^(\s*)(#)(if)(\s+)(0*1)\b/,
            push: [{
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.if.c"
                ],
                regex: /^(\s*)(#\s*)(endif)\b/,
                next: "pop"
            }, {
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.else.c",
                    "text"
                ],
                regex: /^(\s*)(#\s*)(else)\b(.*)/,
                push: [{
                    token: [],
                    regex: /(?=^\s*#\s*endif\b.*$)/,
                    next: "pop"
                }, {
                    include: "#disabled"
                }, {
                    include: "#pragma-mark"
                }, {
                    defaultToken: "comment.block.preprocessor.else-branch.in-block"
                }]
            }, {
                token: "text",
                regex: /(?:)/,
                push: [{
                    token: "text",
                    regex: /(?=^\s*#\s*(?:else|endif)\b.*$)/,
                    next: "pop"
                }, {
                    include: "#block_innards"
                }]
            }]
        }],
        "#preprocessor-rule-other": [{
            token: [
                "text",
                "meta.preprocessor.c",
                "keyword.control.import.c",
                "meta.preprocessor.c"
            ],
            regex: /^(\s*)(#\s*)(if(?:n?def)?)\b(.*?)(?:(?=(?:\/\/|\/\*))|$)/,
            push: [{
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.c",
                    "text"
                ],
                regex: /^(\s*)(#\s*)(endif)\b(.*$)/,
                next: "pop"
            }, {
                include: "$base"
            }]
        }],
        "#preprocessor-rule-other-block": [{
            token: [
                "text",
                "meta.preprocessor.c",
                "keyword.control.import.c",
                "meta.preprocessor.c"
            ],
            regex: /^(\s*)(#\s*)(if(?:n?def)?)\b(.*?)(?:(?=(?:\/\/|\/\*))|$)/,
            push: [{
                token: [
                    "text",
                    "meta.preprocessor.c",
                    "keyword.control.import.c",
                    "text"
                ],
                regex: /^(\s*)(#\s*)(endif)\b(.*$)/,
                next: "pop"
            }, {
                include: "#block_innards"
            }]
        }],
        "#sizeof": [{
            token: "keyword.operator.sizeof.c",
            regex: /\bsizeof\b/
        }],
        "#string_escaped_char": [{
            token: "constant.character.escape.c",
            regex: /\\(?:\\|[abefnprtv'"?]|[0-3]\d{,2}|[4-7]\d?|x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8})/
        }, {
            token: "invalid.illegal.unknown-escape.c",
            regex: /\\./
        }],
        "#string_placeholder": [{
            token: "constant.other.placeholder.c",
            regex: /%(?:\d+\$)?[#0\- +']*[,;:_]?(?:-?\d+|\*(?:-?\d+\$)?)?(?:\.(?:-?\d+|\*(?:-?\d+\$)?)?)?(?:hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?[diouxXDOUeEfFgGaACcSspn%]/
        }, {
            token: "invalid.illegal.placeholder.c",
            regex: /%/
        }]
    }
    
    this.normalizeRules();
};

CHighlightRules.metaData = {
    fileTypes: ["c", "h"],
    firstLineMatch: "-[*]-( Mode:)? C -[*]-",
    foldingStartMarker: "(?x)\n\t\t /\\*\\*(?!\\*)\n\t\t|^(?![^{]*?//|[^{]*?/\\*(?!.*?\\*/.*?\\{)).*?\\{\\s*($|//|/\\*(?!.*?\\*/.*\\S))\n\t",
    foldingStopMarker: "(?<!\\*)\\*\\*/|^\\s*\\}",
    keyEquivalent: "^~C",
    name: "C",
    scopeName: "source.c"
}


oop.inherits(CHighlightRules, TextHighlightRules);

exports.CHighlightRules = CHighlightRules;